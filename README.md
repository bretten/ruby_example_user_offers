# What is it?

The objective of this app is to provide targeted offers to users based on the following demographics:

* Age
* Gender

See the full specifications [here](https://github.com/bretten/ruby_example_user_offers/wiki/Spec).

# What does the app stack look like?

* Ruby on Rails 7 API only backend
    * Allows registration. login, logout
    * Stateless, token-based authentication
    * Serves Offers to authenticated Users
    * Authenticates by checking token in `Authorization` header
* PostgreSQL database
    * Registered users are persisted here
    * Stores Offers (pre-seeded from test file)
    * Stores Offer demographics (age range and gender)
* React frontend
    * React single page application + [react router](https://www.npmjs.com/package/react-router-dom)
    * Stores authentication token from login endpoint in session storage
    * Logout clears session storage

![image](https://user-images.githubusercontent.com/5249819/197590898-2524a736-51d4-4cd6-bef4-46a9ac6e4ae8.png)

# How do you run it locally?

Running it requires docker compose.

From the repository root, run:

```
docker-compose build
docker-compose up -d
```

### How do you stop it?

```
docker-compose stop
docker-compose rm -f
```

### What ports are the containers mapped to?

* `30000` - React frontend
* `30001` - Rails backend
* `54320` - PostgreSQL

### If you change any ports, the following files will need to be updated:

Note: In a real deployment environment, we could replace these using environment variables and string replacement
when the Docker container image is built.

### `docker-compose.yml`

```
- WDS_SOCKET_PORT=30000
```

### `ui/react/app/.env`

```
REACT_APP_OFFERS_BASE_URL=http://localhost:30001
```

### `user_offers/config/initializers/cors.rb`

```
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins 'localhost:30000', 'localhost:30001'
```

# Security

## CSRF

The application disables cookies and instead performs authentication by sending a Bearer Token in the `Authorization`
header.
So a malicious person could not attempt to trick the user into performing requests where credentials may be
automatically be added by the browser (cookies, HTTP basic auth).

The Ruby on Rails backend disables cookies in the `user_offers/config/application.rb`:

```
    config.middleware.delete ActionDispatch::Cookies
    config.middleware.delete ActionDispatch::Session::CookieStore
    config.session_store :disabled
```

## XSS

The application displays no data that was inputted from Users. This means that User A cannot read any data input from
User B.
Any offers are generated by admins. And even if some Offer data managed to contain malicious scripts, when it is
displayed
on the UI, the string would be escaped.

NOTE: Additionally, in a real environment, if you were to use any 3rd party libraries like Bootstrap/MUI/antd, the CI/CD pipeline
could scan installed
versions for vulnerabilities.

## Sessions

Sessions are disabled to prevent any session hijacking.

## Token storage

The app uses stateless, token-based authentication. When the user logs in, they are given a `Bearer Token`. The React
front end will store this in session storage.

Currently, the application does as much as it can to prevent XSS by displaying no user inputted information
and also makes sure to escape any data that is displayed in the browser.

# How are the `Offers` assigned demographics (age and gender)?

There is a join table model
called [OfferDemographic](https://github.com/bretten/ruby_example_user_offers/blob/main/user_offers/app/models/offer_demographic.rb)
.
It has the columns:

* Offer ID
* Minimum age
* Maximum age
* Gender

There is a `hasMany` relationship from `Offer` to `OfferDemographic`. In other words:

* An `Offer` has many `OfferDemographics`
* An `OfferDemographic` belongs to an `Offer`

![image](https://user-images.githubusercontent.com/5249819/197414754-c248fdf6-f456-4bd6-8239-a877eef3fa5d.png)

### How could this have been done differently?

In `OfferDemographic`, aside from the foreign key (`offer_id`), there is no information uniquely tying it to the offer.
For example, consider:

* `Offer_A` has a **minimum age** = 20, **maximum age** = 30, and **gender** = 0
* `Offer_B` is exactly the same and has a **minimum age** = 20, **maximum age** = 30, and **gender** = 0

This would require two separate `OfferDemographic` rows with essentially the same data (just a different `offer_id`).

We could instead normalize the demographic data for all combinations of min age/max age/gender by using
a `has and many belongs to` relationship between `Offer` and `Demographic`.
In other words, the tables would look like:
**Offer**

* id (offer_id)
* Description

**Demographic**

* id (demographic_id)
* minimum_age
* maximum_age
* gender

**OfferDemographic**

* offer_id
* demographic_id

![image](https://user-images.githubusercontent.com/5249819/197414758-579afc02-44b8-4e0b-aa87-6017164e24fb.png)

